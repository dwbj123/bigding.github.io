<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>java的IO流相关问题 | share猿 | https://lywlefan.github.io/</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="java,基础">
    <meta name="description" content="BIO、NIO、AIO、Netty什么是IO Java中I/O是以流为基础进行数据的输入输出的，所有数据被串行化(所谓串行化就是数据要按顺序进行输入输出)写入输出流。简单来说就是java通过io流方式和外部设备进行交互。  在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛：标准输入输出，文件的操作，网络上的数据传输流，字符串流，对象流等等等。     比如程序从服务器上下载图片，">
<meta name="keywords" content="java,基础">
<meta property="og:type" content="article">
<meta property="og:title" content="java的IO流相关问题">
<meta property="og:url" content="https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/index.html">
<meta property="og:site_name" content="share猿">
<meta property="og:description" content="BIO、NIO、AIO、Netty什么是IO Java中I/O是以流为基础进行数据的输入输出的，所有数据被串行化(所谓串行化就是数据要按顺序进行输入输出)写入输出流。简单来说就是java通过io流方式和外部设备进行交互。  在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛：标准输入输出，文件的操作，网络上的数据传输流，字符串流，对象流等等等。     比如程序从服务器上下载图片，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b746125c6~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b74fff5c8~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b771fca9c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b7790530d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b82fb2f64~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b830f1cd3~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba0e18c2d~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba21e5d95~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba9450627~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bae24bd8b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bb4bd288c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bc8b392a2~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd287ea0e~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9df6795~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9e9cea7~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf6b9c467~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bea43363c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf120ce55~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c07f6fd17~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c0e8bc804~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c26ae3362~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c5ec173ed~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c715ef960~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c77b5d822~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ce080820b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d10781adf~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d22d2cf71~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d4362ca3f~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d395b9f07~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d66ef456c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd68f7c10~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d696381b8~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d7a9bf162~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94da3441~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94251e4b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dab69e263~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2da7389a42~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc163e25a~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc2080d3a~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc3e76709~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd02ee59c~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2de8321be5~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dee3a5661~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0284e9ca~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0e2ef4ca~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e4e740749~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:updated_time" content="2021-08-14T10:46:13.497Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java的IO流相关问题">
<meta name="twitter:description" content="BIO、NIO、AIO、Netty什么是IO Java中I/O是以流为基础进行数据的输入输出的，所有数据被串行化(所谓串行化就是数据要按顺序进行输入输出)写入输出流。简单来说就是java通过io流方式和外部设备进行交互。  在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛：标准输入输出，文件的操作，网络上的数据传输流，字符串流，对象流等等等。     比如程序从服务器上下载图片，">
<meta name="twitter:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b746125c6~tplv-t2oaga2asx-watermark.awebp">
    
        <link rel="alternate" type="application/atom+xml" title="share猿" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">share猿</h5>
          <a href="mailto:330334064@qq.com" title="330334064@qq.com" class="mail">330334064@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lywlefan" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                GitHub
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom">
                <i class="icon icon-lg icon-rss"></i>
                订阅
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">java的IO流相关问题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">java的IO流相关问题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-31T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2020-04-01
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/后端/">后端</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BIO、NIO、AIO、Netty"><span class="post-toc-number">1.</span> <span class="post-toc-text">BIO、NIO、AIO、Netty</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是IO"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">什么是IO</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是BIO"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">什么是BIO</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是NIO"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">什么是NIO</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是AIO"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">什么是AIO</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么Netty"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">什么Netty</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BIO和NIO、AIO的区别"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">BIO和NIO、AIO的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IO流的分类"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">IO流的分类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是内核空间"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">什么是内核空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#五种IO模型"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">五种IO模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-阻塞BIO（blocking-I-O）"><span class="post-toc-number">1.0.10.1.</span> <span class="post-toc-text">1.阻塞BIO（blocking I/O）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-非阻塞NIO（noblocking-I-O）"><span class="post-toc-number">1.0.10.2.</span> <span class="post-toc-text">2.非阻塞NIO（noblocking I/O）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-异步AIO（asynchronous-I-O）"><span class="post-toc-number">1.0.10.3.</span> <span class="post-toc-text">3.异步AIO（asynchronous I/O）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-信号驱动IO（signal-blocking-I-O）"><span class="post-toc-number">1.0.10.4.</span> <span class="post-toc-text">4.信号驱动IO（signal blocking I/O）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5-IO多路转接（I-O-multiplexing）"><span class="post-toc-number">1.0.10.5.</span> <span class="post-toc-text">5.IO多路转接（I/O multiplexing）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是比特-Bit-什么是字节-Byte-什么是字符-Char-它们长度是多少-各有什么区别"><span class="post-toc-number">1.0.11.</span> <span class="post-toc-text">什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作"><span class="post-toc-number">1.0.12.</span> <span class="post-toc-text">什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在实现序列化接口是时候一般要生成一个serialVersionUID字段-它叫做什么-一般有什么用"><span class="post-toc-number">1.0.13.</span> <span class="post-toc-text">在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#怎么生成SerialversionUID"><span class="post-toc-number">1.0.14.</span> <span class="post-toc-text">怎么生成SerialversionUID</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#BufferedReader属于哪种流-它主要是用来做什么的-它里面有那些经典的方法"><span class="post-toc-number">1.0.15.</span> <span class="post-toc-text">BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java中流类的超类主要有那些？"><span class="post-toc-number">1.0.16.</span> <span class="post-toc-text">Java中流类的超类主要有那些？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么图片、视频、音乐、文件等-都是要字节流来读取"><span class="post-toc-number">1.0.17.</span> <span class="post-toc-text">为什么图片、视频、音乐、文件等 都是要字节流来读取</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IO的常用类和方法，以及如何使用"><span class="post-toc-number">1.0.18.</span> <span class="post-toc-text">IO的常用类和方法，以及如何使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#IO基本操作讲解"><span class="post-toc-number">1.0.19.</span> <span class="post-toc-text">IO基本操作讲解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-按字符流读取文件"><span class="post-toc-number">1.0.19.1.</span> <span class="post-toc-text">1 按字符流读取文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#1-1-按字符流的·节点流方式读取"><span class="post-toc-number">1.0.19.1.1.</span> <span class="post-toc-text">1.1 按字符流的·节点流方式读取</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#1-2-按字符流的·处理流方式读取"><span class="post-toc-number">1.0.19.1.2.</span> <span class="post-toc-text">1.2 按字符流的·处理流方式读取</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-按字符流写出文件"><span class="post-toc-number">1.0.19.2.</span> <span class="post-toc-text">2 按字符流写出文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2-1-按字符流的·节点流方式写出"><span class="post-toc-number">1.0.19.2.1.</span> <span class="post-toc-text">2.1 按字符流的·节点流方式写出</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2-2-按字符流的·处理流方式写出"><span class="post-toc-number">1.0.19.2.2.</span> <span class="post-toc-text">2.2 按字符流的·处理流方式写出</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-按字节流写入写出文件"><span class="post-toc-number">1.0.19.3.</span> <span class="post-toc-text">3 按字节流写入写出文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#3-1-按字节流的·节点流写入写出文件"><span class="post-toc-number">1.0.19.3.1.</span> <span class="post-toc-text">3.1 按字节流的·节点流写入写出文件</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#3-2-按字节流的·处理流写入写出文件"><span class="post-toc-number">1.0.19.3.2.</span> <span class="post-toc-text">3.2 按字节流的·处理流写入写出文件</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#网络操作IO讲解"><span class="post-toc-number">1.0.20.</span> <span class="post-toc-text">网络操作IO讲解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#网络操作IO编程演变历史"><span class="post-toc-number">1.0.21.</span> <span class="post-toc-text">网络操作IO编程演变历史</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-BIO编程会出现什么问题？"><span class="post-toc-number">1.0.21.1.</span> <span class="post-toc-text">1 BIO编程会出现什么问题？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-多线程解决BIO编程会出现的问题"><span class="post-toc-number">1.0.21.2.</span> <span class="post-toc-text">2 多线程解决BIO编程会出现的问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-线程池解决多线程BIO编程会出现的问题"><span class="post-toc-number">1.0.21.3.</span> <span class="post-toc-text">3 线程池解决多线程BIO编程会出现的问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-使用NIO实现网络通信"><span class="post-toc-number">1.0.21.4.</span> <span class="post-toc-text">4 使用NIO实现网络通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#什么是通道（Channel）"><span class="post-toc-number">1.0.21.4.1.</span> <span class="post-toc-text">什么是通道（Channel）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#什么是选择器（Selector）"><span class="post-toc-number">1.0.21.4.2.</span> <span class="post-toc-text">什么是选择器（Selector）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#什么是Buffer（缓冲区）"><span class="post-toc-number">1.0.21.4.3.</span> <span class="post-toc-text">什么是Buffer（缓冲区）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#代码实例："><span class="post-toc-number">1.0.21.4.4.</span> <span class="post-toc-text">代码实例：</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5-使用Netty实现网络通信"><span class="post-toc-number">1.0.21.5.</span> <span class="post-toc-text">5 使用Netty实现网络通信</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-软件研发/后端/基础巩固/java/流/java流相关问题" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">java的IO流相关问题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-01 00:00:00" datetime="2020-03-31T16:00:00.000Z" itemprop="datePublished">2020-04-01</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/后端/">后端</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="BIO、NIO、AIO、Netty"><a href="#BIO、NIO、AIO、Netty" class="headerlink" title="BIO、NIO、AIO、Netty"></a>BIO、NIO、AIO、Netty</h2><h4 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h4><ul>
<li><p>Java中I/O是以流为基础进行数据的输入输出的，所有数据被串行化(所谓串行化就是数据要按顺序进行输入输出)写入输出流。简单来说就是java通过io流方式和外部设备进行交互。</p>
</li>
<li><p>在Java类库中，IO部分的内容是很庞大的，因为它涉及的领域很广泛：标准输入输出，文件的操作，<strong>网络上的数据传输流</strong>，字符串流，对象流等等等。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b746125c6~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li>比如程序从服务器上下载图片，就是通过流的方式从网络上以流的方式到程序中，在到硬盘中</li>
</ul>
<h4 id="在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别"><a href="#在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别" class="headerlink" title="在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别"></a>在了解不同的IO之前先了解：同步与异步，阻塞与非阻塞的区别</h4><ul>
<li>同步，一个任务的完成之前不能做其他操作，必须等待（等于在打电话）</li>
<li>异步，一个任务的完成之前，可以进行其他操作（等于在聊QQ）</li>
<li>阻塞，是相对于CPU来说的， 挂起当前线程，不能做其他操作只能等待</li>
<li>非阻塞,，无须挂起当前线程，可以去执行其他操作</li>
</ul>
<h4 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO"></a>什么是BIO</h4><ul>
<li>BIO：同步并阻塞，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，没处理完之前此线程不能做其他操作（如果是单线程的情况下，我传输的文件很大呢？），当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
</ul>
<h4 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h4><ul>
<li>NIO:同步非阻塞，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</li>
</ul>
<h4 id="什么是AIO"><a href="#什么是AIO" class="headerlink" title="什么是AIO"></a>什么是AIO</h4><ul>
<li>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK1.7之后开始支持。.</li>
<li>AIO属于NIO包中的类实现，其实IO主要分为BIO和NIO，AIO只是附加品，解决IO不能异步的实现</li>
<li>在以前很少有Linux系统支持AIO，Windows的IOCP就是该AIO模型。但是现在的服务器一般都是支持AIO操作</li>
</ul>
<h4 id="什么Netty"><a href="#什么Netty" class="headerlink" title="什么Netty"></a>什么Netty</h4><ul>
<li><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
</li>
<li><p>Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b74fff5c8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>Netty是由NIO演进而来，使用过NIO编程的用户就知道NIO编程非常繁重，Netty是能够能跟好的使用NIO</p>
</li>
</ul>
<h4 id="BIO和NIO、AIO的区别"><a href="#BIO和NIO、AIO的区别" class="headerlink" title="BIO和NIO、AIO的区别"></a>BIO和NIO、AIO的区别</h4><ul>
<li>BIO是阻塞的，NIO是非阻塞的.</li>
<li>BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写</li>
<li>使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接</li>
<li>AIO是非阻塞 以异步方式发起 I/O 操作。当 I/O 操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成（不懂的可以往下看）</li>
</ul>
<h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b771fca9c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p><strong>按照读写的单位大小来分：</strong></p>
<ul>
<li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li>
<li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li>
</ul>
<p><strong>按照实际IO操作来分：</strong></p>
<ul>
<li>输出流：从内存读出到文件。只能进行写操作。</li>
<li>输入流：从文件读入到内存。只能进行读操作。</li>
<li><strong>注意</strong>：输出流可以帮助我们创建文件，而输入流不会。</li>
</ul>
<p><strong>按照读写时是否直接与硬盘，内存等节点连接分：</strong></p>
<ul>
<li>节点流：直接与数据源相连，读入或读出。</li>
<li>处理流：也叫包装流，是对一个对于已存在的流的连接进行封装，通过所封装的流的功能调用实现数据读写。如添加个Buffering缓冲区。（意思就是有个缓存区，等于软件和mysql中的redis）</li>
<li><strong>注意</strong>：为什么要有处理流？主要作用是在读入或写出时，对数据进行缓存，以减少I/O的次数，以便下次更好更快的读写文件，才有了处理流。</li>
</ul>
<h4 id="什么是内核空间"><a href="#什么是内核空间" class="headerlink" title="什么是内核空间"></a>什么是内核空间</h4><ul>
<li>我们的应用程序是不能直接访问硬盘的，我们程序没有权限直接访问，但是操作系统（Windows、Linux……）会给我们一部分权限较高的内存空间，他叫内核空间，和我们的实际硬盘空间是有区别的</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b7790530d~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ul>
<li><strong>注意：我这里的用户空间就是应用程序空间</strong></li>
</ul>
<h5 id="1-阻塞BIO（blocking-I-O）"><a href="#1-阻塞BIO（blocking-I-O）" class="headerlink" title="1.阻塞BIO（blocking I/O）"></a>1.阻塞BIO（blocking I/O）</h5><ul>
<li><p>A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</p>
</li>
<li><p>在内核将数据准备好之前，系统调用会一直等待所有的套接字，默认的是阻塞方式。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b82fb2f64~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h5 id="2-非阻塞NIO（noblocking-I-O）"><a href="#2-非阻塞NIO（noblocking-I-O）" class="headerlink" title="2.非阻塞NIO（noblocking I/O）"></a>2.非阻塞NIO（noblocking I/O）</h5><ul>
<li>B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。 <strong>B在检查鱼竿是否有鱼，是一个轮询的过程。</strong></li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2b830f1cd3~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h5 id="3-异步AIO（asynchronous-I-O）"><a href="#3-异步AIO（asynchronous-I-O）" class="headerlink" title="3.异步AIO（asynchronous I/O）"></a>3.异步AIO（asynchronous I/O）</h5><ul>
<li><p>C也想钓鱼，但C有事情，于是他雇来了D、E、F，让他们帮他等待鱼上钩，一旦有鱼上钩，就打电话给C，C就会将鱼钓上去。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba0e18c2d~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>当应用程序请求数据时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。</p>
</li>
</ul>
<h5 id="4-信号驱动IO（signal-blocking-I-O）"><a href="#4-信号驱动IO（signal-blocking-I-O）" class="headerlink" title="4.信号驱动IO（signal blocking I/O）"></a>4.信号驱动IO（signal blocking I/O）</h5><ul>
<li><p>G也在河边钓鱼，但与A、B、C不同的是，G比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，G就会将鱼钓上来。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba21e5d95~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p>
</li>
</ul>
<h5 id="5-IO多路转接（I-O-multiplexing）"><a href="#5-IO多路转接（I-O-multiplexing）" class="headerlink" title="5.IO多路转接（I/O multiplexing）"></a>5.IO多路转接（I/O multiplexing）</h5><ul>
<li><p>H同样也在河边钓鱼，但是H生活水平比较好，H拿了很多的鱼竿，一次性有很多鱼竿在等，H不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ba9450627~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。</p>
</li>
</ul>
<ul>
<li>IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高。</li>
</ul>
<h4 id="什么是比特-Bit-什么是字节-Byte-什么是字符-Char-它们长度是多少-各有什么区别"><a href="#什么是比特-Bit-什么是字节-Byte-什么是字符-Char-它们长度是多少-各有什么区别" class="headerlink" title="什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别"></a>什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别</h4><ul>
<li>Bit最小的二进制单位 ，是计算机的操作部分取值0或者1</li>
<li>Byte是计算机中存储数据的单元，是一个8位的二进制数，（计算机内部，一个字节可表示一个英文字母，两个字节可表示一个汉字。） <code>取值（-128-127）</code></li>
<li>Char是用户的可读写的最小单位，他只是抽象意义上的一个符号。如‘5’，‘中’，‘￥’ 等等等等。在java里面由16位bit组成Char 取值<code>（0-65535）</code></li>
<li>Bit 是最小单位 计算机他只能认识0或者1</li>
<li>Byte是8个字节  是给计算机看的</li>
<li>字符 是看到的东西  一个字符=二个字节</li>
</ul>
<h4 id="什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作"><a href="#什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作" class="headerlink" title="什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作"></a>什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作</h4><ul>
<li>对象序列化，将对象以二进制的形式保存在硬盘上</li>
<li>反序列化；将二进制的文件转化为对象读取</li>
<li>实现serializable接口，不想让字段放在硬盘上就加transient</li>
</ul>
<h4 id="在实现序列化接口是时候一般要生成一个serialVersionUID字段-它叫做什么-一般有什么用"><a href="#在实现序列化接口是时候一般要生成一个serialVersionUID字段-它叫做什么-一般有什么用" class="headerlink" title="在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用"></a>在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用</h4><ul>
<li>如果用户没有自己声明一个serialVersionUID,接口会默认生成一个serialVersionUID</li>
<li>但是强烈建议用户自定义一个serialVersionUID,因为默认的serialVersinUID对于class的细节非常敏感，反序列化时可能会导致InvalidClassException这个异常。</li>
<li>（比如说先进行序列化，然后在反序列化之前修改了类，那么就会报错。因为修改了类，对应的SerialversionUID也变化了，而序列化和反序列化就是通过对比其SerialversionUID来进行的，一旦SerialversionUID不匹配，反序列化就无法成功。</li>
</ul>
<h4 id="怎么生成SerialversionUID"><a href="#怎么生成SerialversionUID" class="headerlink" title="怎么生成SerialversionUID"></a>怎么生成SerialversionUID</h4><ul>
<li>可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段<strong>必须是静态 (static)、最终 (final) 的 long 型字段</strong>）显式声明其自己的 serialVersionUID</li>
<li>两种显示的生成方式（当你一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义 。在Eclipse中点击类中warning的图标一下，Eclipse就会自动给定两种生成的方式。</li>
</ul>
<h4 id="BufferedReader属于哪种流-它主要是用来做什么的-它里面有那些经典的方法"><a href="#BufferedReader属于哪种流-它主要是用来做什么的-它里面有那些经典的方法" class="headerlink" title="BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法"></a>BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法</h4><ul>
<li>属于处理流中的缓冲流，可以将读取的内容存在内存里面，有readLine（）方法</li>
</ul>
<h4 id="Java中流类的超类主要有那些？"><a href="#Java中流类的超类主要有那些？" class="headerlink" title="Java中流类的超类主要有那些？"></a>Java中流类的超类主要有那些？</h4><ul>
<li>超类代表顶端的父类（都是抽象类）</li>
<li>java.io.InputStream</li>
<li>java.io.OutputStream</li>
<li>java.io.Reader</li>
<li>java.io.Writer</li>
</ul>
<h4 id="为什么图片、视频、音乐、文件等-都是要字节流来读取"><a href="#为什么图片、视频、音乐、文件等-都是要字节流来读取" class="headerlink" title="为什么图片、视频、音乐、文件等 都是要字节流来读取"></a>为什么图片、视频、音乐、文件等 都是要字节流来读取</h4><ul>
<li>这个很基础，你看看你电脑文件的属性就好了，CPU规定了计算机存储文件都是按字节算的</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bae24bd8b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<h4 id="IO的常用类和方法，以及如何使用"><a href="#IO的常用类和方法，以及如何使用" class="headerlink" title="IO的常用类和方法，以及如何使用"></a>IO的常用类和方法，以及如何使用</h4><p><a href="#Mark">注意，如果懂IO的普通文件读写操作可以直接点击此处跳过，直接看网络操作IO编程，那个才是重点，点击即会跳转</a></p>
<p>前面讲了那么多废话，现在我们开始进入主题，后面很长，从开始的文件操作到后面的<strong>网络IO操作</strong>都会有例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bb4bd288c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述" title>
                </div>
                <div class="image-caption">在这里插入图片描述</div>
            </figure>
<p><a href="#Mark">注意，如果懂IO的普通文件读写操作可以直接点击此处跳过，直接看网络操作IO编程，那个才是重点，点击即会跳转</a></p>
<h4 id="IO基本操作讲解"><a href="#IO基本操作讲解" class="headerlink" title="IO基本操作讲解"></a>IO基本操作讲解</h4><ul>
<li><code>这里的基本操作就是普通的读取操作，如果想要跟深入的了解不同的IO开发场景必须先了解IO的基本操作</code></li>
</ul>
<h5 id="1-按字符流读取文件"><a href="#1-按字符流读取文件" class="headerlink" title="1 按字符流读取文件"></a>1 按<code>字符</code>流读取文件</h5><h6 id="1-1-按字符流的·节点流方式读取"><a href="#1-1-按字符流的·节点流方式读取" class="headerlink" title="1.1 按字符流的·节点流方式读取"></a>1.1 按字符流的·节点流方式读取</h6><ul>
<li>如果我们要取的数据基本单位是字符，那么用（<strong>字符流</strong>）这种方法读取文件就比较适合。比如：读取test.txt文件</li>
</ul>
<p><strong>注释：</strong></p>
<ul>
<li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li>
<li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li>
<li><strong>FileReader 类：</strong>（字符输入流） 注意：new FileReader(“D:\test.txt”);//文件必须存在</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestFileReader &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        //字符流接收使用的char数组</span><br><span class="line">        char[] buf=new char[1024];</span><br><span class="line">        //字符流、节点流打开文件类</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\test.txt&quot;);//文件必须存在</span><br><span class="line">        //FileReader.read()：取出字符存到buf数组中,如果读取为-1代表为空即结束读取。</span><br><span class="line">        //FileReader.read()：读取的是一个字符，但是java虚拟机会自动将char类型数据转换为int数据，</span><br><span class="line">        //如果你读取的是字符A，java虚拟机会自动将其转换成97，如果你想看到字符可以在返回的字符数前加（char）强制转换如</span><br><span class="line">        while((num=fr.read(buf))!=-1) &#123; &#125;</span><br><span class="line">        //检测一下是否取到相应的数据</span><br><span class="line">        for(int i=0;i&lt;buf.length;i++) &#123;</span><br><span class="line">            System.out.print(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行结果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bc8b392a2~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>·</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd287ea0e~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h6 id="1-2-按字符流的·处理流方式读取"><a href="#1-2-按字符流的·处理流方式读取" class="headerlink" title="1.2 按字符流的·处理流方式读取"></a>1.2 按字符流的·处理流方式读取</h6><ul>
<li>效果是一样，但是给了我们有不同的选择操作。进行了一个小封装，加缓冲功能，避免频繁读写硬盘。我这只是简单演示，处理流其实还有很多操作</li>
<li><strong>BufferedReader 类：</strong> 字符输入流使用的类，加缓冲功能，避免频繁读写硬盘</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestBufferedReader &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        //字符流接收使用的String数组</span><br><span class="line">        String[] bufstring=new String[1024];</span><br><span class="line">        //字符流、节点流打开文件类</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\test.txt&quot;);//文件必须存在</span><br><span class="line">        //字符流、处理流读取文件类</span><br><span class="line">        BufferedReader br = new BufferedReader(fr);</span><br><span class="line">        //临时接收数据使用的变量</span><br><span class="line">        String line=null;</span><br><span class="line">        //BufferedReader.readLine()：单行读取，读取为空返回null</span><br><span class="line">        while((line=br.readLine())!=null) &#123;</span><br><span class="line">            bufstring[num]=line;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();//关闭文件</span><br><span class="line">        for(int i=0;i&lt;num;i++) &#123;</span><br><span class="line">            System.out.println(bufstring[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试效果一样</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9df6795~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h5 id="2-按字符流写出文件"><a href="#2-按字符流写出文件" class="headerlink" title="2 按字符流写出文件"></a>2 按<code>字符</code>流写出文件</h5><h6 id="2-1-按字符流的·节点流方式写出"><a href="#2-1-按字符流的·节点流方式写出" class="headerlink" title="2.1 按字符流的·节点流方式写出"></a>2.1 按字符流的·节点流方式写出</h6><ul>
<li>写出字符，使用（<strong>字符流</strong>）这种方法写出文件比较适合。比如：输出内容添加到test.txt文件</li>
<li><strong>FileWriter类：</strong>（字符输出流），如果写出文件不存在会自动创建一个相对应的文件。使用FileWriter写出文件默认是覆盖原文件，如果要想在源文件添加内容不覆盖的话，需要构造参数添加true参数：看示例了解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestFileWriter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //File是操作文件类</span><br><span class="line">        File file = new File(&quot;D:\\test.txt&quot;);//文件必须存在</span><br><span class="line">        //字符流、节点流写出文件类</span><br><span class="line">        //new FileWriter(file,true)，这个true代表追加，不写就代表覆盖文件</span><br><span class="line">        FileWriter out=new FileWriter(file,true);</span><br><span class="line">        //写入的字节,\n代表换行</span><br><span class="line">        String str=&quot;\nholler&quot;;</span><br><span class="line">        //写入</span><br><span class="line">        out.write(str);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行效果</p>
<p>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bd9e9cea7~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h6 id="2-2-按字符流的·处理流方式写出"><a href="#2-2-按字符流的·处理流方式写出" class="headerlink" title="2.2 按字符流的·处理流方式写出"></a>2.2 按字符流的·处理流方式写出</h6><ul>
<li><strong>BufferedWriter ：</strong> 增加缓冲功能，避免频繁读写硬盘。 我这里： //new FileWriter(file)，这里我只给了他文件位置，我没加true代表覆盖源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class TestBufferedWriter &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //File是操作文件类</span><br><span class="line">        File file = new File(&quot;D:\\test.txt&quot;);//文件必须存在</span><br><span class="line">        //字符流、节点流写出文件类</span><br><span class="line">        //new FileWriter(file)，这个我没加true代表覆盖文件</span><br><span class="line">        Writer writer = new FileWriter(file);</span><br><span class="line">        ////字符流、处理流写出文件类</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(writer);</span><br><span class="line">        bw.write(&quot;\n小心&quot;);</span><br><span class="line">        bw.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行效果</p>
<p>：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf6b9c467~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h5 id="3-按字节流写入写出文件"><a href="#3-按字节流写入写出文件" class="headerlink" title="3 按字节流写入写出文件"></a>3 按<code>字节</code>流写入写出文件</h5><h6 id="3-1-按字节流的·节点流写入写出文件"><a href="#3-1-按字节流的·节点流写入写出文件" class="headerlink" title="3.1 按字节流的·节点流写入写出文件"></a>3.1 按字节流的·节点流写入写出文件</h6><ul>
<li>如果我们要取的数据 图片、文件、音乐视频等类型，就必须使用字节流进行读取写出</li>
</ul>
<p><strong>注释：</strong></p>
<ul>
<li><code>字符流</code>：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。 (Java代码接收数据为一般为<code>char数组，也可以是别的</code>)</li>
<li>字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据，图片、文件、音乐视频等。 (Java代码接收数据只能为<code>byte数组</code>)</li>
<li><strong>FileInputStream：</strong>（字节输入流）</li>
<li><strong>FileOutputStream：</strong>（字节输出流）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class TestFileOutputStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建字节输入流、节点流方式读取文件</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\Akie秋绘 - Lemon（Cover：米津玄師）.mp3&quot;);</span><br><span class="line">        //创建字节输入流、节点流方式输出文件</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\copy.mp3&quot;);</span><br><span class="line"></span><br><span class="line">        //根据文件大小做一个字节数组</span><br><span class="line">        byte[] arr = new byte[fis.available()];</span><br><span class="line">        //将文件上的所有字节读取到数组中</span><br><span class="line">        fis.read(arr);</span><br><span class="line">        //将数组中的所有字节一次写到了文件上</span><br><span class="line">        fos.write(arr);</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行之前：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bea43363c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>运行之后：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2bf120ce55~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h6 id="3-2-按字节流的·处理流写入写出文件"><a href="#3-2-按字节流的·处理流写入写出文件" class="headerlink" title="3.2 按字节流的·处理流写入写出文件"></a>3.2 按字节流的·处理流写入写出文件</h6><ul>
<li><strong>FileInputStream：</strong>（字节输入流）</li>
<li><strong>FileOutputStream：</strong>（字节输出流）</li>
<li><strong>BufferedInputStream</strong>：（带缓冲区字节输入流）</li>
<li><strong>BufferedOutputStream</strong>：（带缓冲区字节输入流） 带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class TestBufferedOutputStream &#123;</span><br><span class="line">    //创建文件输入流对象,关联致青春.mp3</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\copy.mp3&quot;);</span><br><span class="line">        //创建缓冲区对fis装饰</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(fis);</span><br><span class="line">        //创建输出流对象,关联copy.mp3</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\copy2.mp3&quot;);</span><br><span class="line">        //创建缓冲区对fos装饰</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">        //循环直接输出</span><br><span class="line">        int i;</span><br><span class="line">        while((i = bis.read()) != -1) &#123;</span><br><span class="line">            bos.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行之前：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c07f6fd17~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>运行之后：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c0e8bc804~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="网络操作IO讲解"><a href="#网络操作IO讲解" class="headerlink" title="网络操作IO讲解"></a>网络操作IO讲解</h4><ul>
<li>我这使用Socket简单的来模拟网络编程IO会带来的问题</li>
<li>不懂Socket可以看我之前的文章，这个东西很容易懂的，就是基于TCP实现的网络通信，比http要快，很多实现网络通信的框架都是基于Socket来实现 </li>
</ul>
<h4 id="网络操作IO编程演变历史"><a href="#网络操作IO编程演变历史" class="headerlink" title="网络操作IO编程演变历史"></a>网络操作IO编程演变历史</h4><h5 id="1-BIO编程会出现什么问题？"><a href="#1-BIO编程会出现什么问题？" class="headerlink" title="1 BIO编程会出现什么问题？"></a>1 BIO编程会出现什么问题？</h5><ul>
<li><p>BIO是阻塞的</p>
</li>
<li><p><strong>例子：</strong> 阻塞IO（blocking I/O） A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c26ae3362~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li><p>看起来没问题，但是我很多请求一起发送请求资源怎么办：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c5ec173ed~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>那不是要等待第一个人资源完成后后面的人才可以继续？</p>
<p>因为BIO是阻塞的所以读取写出操作都是非常浪费资源的</p>
</li>
</ul>
<p><strong>BIO代码示例：</strong>（<code>后面有代码，往后移动一点点，认真看，代码学习量很足</code>）</p>
<ul>
<li><p>我这有三个类，我模拟启动服务端，然后启动客户端，模拟客户端操作未完成的时候启动第二个客户端</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c715ef960~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<ol>
<li><p>启动服务端（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面有代码，我这是教运行顺序</span><br></pre></td></tr></table></figure>
<p>）</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2c77b5d822~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
<li><p>启动第一个客户端，发现服务器显示连接成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先不要在控制台 输入 ，模拟堵塞。（我的代码输入了就代表请求完成了）</span><br></pre></td></tr></table></figure>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2ce080820b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>·</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d10781adf~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
<li><p>启动第二个客户端，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现服务端没效果</span><br></pre></td></tr></table></figure>
<p>，而客户端连接成功（在堵塞当中）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我这启动了俩个Client，注意看，(这俩个代码是一样的)</span><br></pre></td></tr></table></figure>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d22d2cf71~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>·</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d4362ca3f~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
<li><p>第一个客户控制台输入，输入完后就会关闭第一个客户端， 在看服务端发现第二个客户端连接上来了</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d395b9f07~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>·</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d66ef456c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><strong>BIO通信代码：</strong></p>
<ul>
<li>TCP协议Socket使用BIO进行通信：服务端（先执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket使用BIO进行通信：服务端</span><br><span class="line">public class BIOServer &#123;</span><br><span class="line">    // 在main线程中执行下面这些代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用Socket进行网络通信</span><br><span class="line">        ServerSocket server = null;</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        //基于字节流</span><br><span class="line">        InputStream in = null;</span><br><span class="line">        OutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            server = new ServerSocket(8000);</span><br><span class="line">            System.out.println(&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;);</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                socket = server.accept(); //等待客户端连接</span><br><span class="line">                System.out.println(&quot;客户连接成功，客户信息为：&quot; + socket.getRemoteSocketAddress());</span><br><span class="line">                in = socket.getInputStream();</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int len = 0;</span><br><span class="line">                //读取客户端的数据</span><br><span class="line">                while ((len = in.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                    System.out.println(new String(buffer, 0, len));</span><br><span class="line">                &#125;</span><br><span class="line">                //向客户端写数据</span><br><span class="line">                out = socket.getOutputStream();</span><br><span class="line">                out.write(&quot;hello!&quot;.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP协议Socket使用BIO进行通信：客户端（第二执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket使用BIO进行通信：客户端</span><br><span class="line">public class Client01 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建套接字对象socket并封装ip与port</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8000);</span><br><span class="line">        //根据创建的socket对象获得一个输出流</span><br><span class="line">        //基于字节流</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        //控制台输入以IO的形式发送到服务器</span><br><span class="line">        System.out.println(&quot;TCP连接成功 \n请输入：&quot;);</span><br><span class="line">        String str = new Scanner(System.in).nextLine();</span><br><span class="line">        byte[] car = str.getBytes();</span><br><span class="line">        outputStream.write(car);</span><br><span class="line">        System.out.println(&quot;TCP协议的Socket发送成功&quot;);</span><br><span class="line">        //刷新缓冲区</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        //关闭连接</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP协议Socket使用BIO进行通信：客户端（第三执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket：客户端</span><br><span class="line">public class Client02 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建套接字对象socket并封装ip与port</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8000);</span><br><span class="line">        //根据创建的socket对象获得一个输出流</span><br><span class="line">        //基于字节流</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        //控制台输入以IO的形式发送到服务器</span><br><span class="line">        System.out.println(&quot;TCP连接成功 \n请输入：&quot;);</span><br><span class="line">        String str = new Scanner(System.in).nextLine();</span><br><span class="line">        byte[] car = str.getBytes();</span><br><span class="line">        outputStream.write(car);</span><br><span class="line">        System.out.println(&quot;TCP协议的Socket发送成功&quot;);</span><br><span class="line">        //刷新缓冲区</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        //关闭连接</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">为了解决堵塞问题，可以使用多线程，请看下面</span><br></pre></td></tr></table></figure>
<h5 id="2-多线程解决BIO编程会出现的问题"><a href="#2-多线程解决BIO编程会出现的问题" class="headerlink" title="2 多线程解决BIO编程会出现的问题"></a>2 多线程解决BIO编程会出现的问题</h5><p><strong>这时有人就会说，我多线程不就解决了吗?</strong></p>
<ul>
<li><p>使用多线程是可以解决堵塞等待时间很长的问题，因为他可以充分发挥CPU</p>
</li>
<li><p>然而系统资源是有限的，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd68f7c10~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>万一请求越来越多，线程越来越多那我CPU不就炸了？</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d696381b8~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述" title>
                </div>
                <div class="image-caption">在这里插入图片描述</div>
            </figure>
<p><strong>多线程BIO代码示例：</strong></p>
<ul>
<li><p>四个客户端，这次我多复制了俩个一样客户端类</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d7a9bf162~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先启动服务端，在启动所有客户端，测试</span><br></pre></td></tr></table></figure>
<p>，发现连接成功（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面有代码</span><br></pre></td></tr></table></figure>
<p>）</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94da3441~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>在所有客户端输入消息（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client01、Client02这些是我在客户端输入的消息</span><br></pre></td></tr></table></figure>
<p>）：发现没有问题</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2d94251e4b~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>多线程BIO通信代码：</strong></p>
<ul>
<li><code>服务端的代码，客户端的代码还是上面之前的代码</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket使用多线程BIO进行通行：服务端</span><br><span class="line">public class BIOThreadService &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket server = new ServerSocket(8000);</span><br><span class="line">            System.out.println(&quot;服务端启动成功，监听端口为8000，等待客户端连接... &quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket socket = server.accept();//等待客户连接</span><br><span class="line">                System.out.println(&quot;客户连接成功，客户信息为：&quot; + socket.getRemoteSocketAddress());</span><br><span class="line">                //针对每个连接创建一个线程， 去处理I0操作</span><br><span class="line">                //创建多线程创建开始</span><br><span class="line">                Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            InputStream in = socket.getInputStream();</span><br><span class="line">                            byte[] buffer = new byte[1024];</span><br><span class="line">                            int len = 0;</span><br><span class="line">                            //读取客户端的数据</span><br><span class="line">                            while ((len = in.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                                System.out.println(new String(buffer, 0, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                            //向客户端写数据</span><br><span class="line">                            OutputStream out = socket.getOutputStream();</span><br><span class="line">                            out.write(&quot;hello&quot;.getBytes());</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line">为了解决线程太多，这时又来了，线程池</span><br></pre></td></tr></table></figure>
<h5 id="3-线程池解决多线程BIO编程会出现的问题"><a href="#3-线程池解决多线程BIO编程会出现的问题" class="headerlink" title="3 线程池解决多线程BIO编程会出现的问题"></a>3 线程池解决多线程BIO编程会出现的问题</h5><p><strong>这时有人就会说，我TM用线程池?</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dab69e263~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述" title>
                </div>
                <div class="image-caption">在这里插入图片描述</div>
            </figure>
<ul>
<li>线程池固然可以解决这个问题，万一需求量还不够还要扩大线程池。当是这是我们自己靠着自己的思想完成的IO操作，Socket 上来了就去创建线程去抢夺CPU资源，MD，线程都TM做IO去了，CPU也不舒服呀</li>
<li>这时呢：Jdk官方坐不住了，兄弟BIO的问题交给我，我来给你解决：<code>NIO的诞生</code></li>
</ul>
<p><strong>线程池BIO代码示例：</strong></p>
<ul>
<li><p>四个客户端</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2da7389a42~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先启动服务端，在启动所有客户端，测试</span><br></pre></td></tr></table></figure>
<p>，（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面有代码</span><br></pre></td></tr></table></figure>
<p>）</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc163e25a~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>在所有客户端输入消息（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client01、Client02这些是我在客户端输入的消息</span><br></pre></td></tr></table></figure>
<p>）：发现没有问题</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc2080d3a~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>线程池BIO通信代码：</strong></p>
<ul>
<li><code>服务端的代码，客户端的代码还是上面的代码</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket使用线程池BIO进行通行：服务端</span><br><span class="line">public class BIOThreadPoolService &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(30);</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket server = new ServerSocket(8000);</span><br><span class="line">            System.out.println(&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket socket = server.accept();//等待客户连接</span><br><span class="line">                System.out.println(&quot;客户连接成功，客户信息为：&quot; + socket.getRemoteSocketAddress());</span><br><span class="line">                //使用线程池中的线程去执行每个对应的任务</span><br><span class="line">                executorService.execute(new Thread(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            InputStream in = socket.getInputStream();</span><br><span class="line">                            byte[] buffer = new byte[1024];</span><br><span class="line">                            int len = 0;</span><br><span class="line">                            //读取客户端的数据</span><br><span class="line">                            while ((len = in.read(buffer)) &gt; 0) &#123;</span><br><span class="line">                                System.out.println(new String(buffer, 0, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                            //向客户端写数据</span><br><span class="line">                            OutputStream out = socket.getOutputStream();</span><br><span class="line">                            out.write(&quot;hello&quot;.getBytes());</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="4-使用NIO实现网络通信"><a href="#4-使用NIO实现网络通信" class="headerlink" title="4 使用NIO实现网络通信"></a>4 使用NIO实现网络通信</h5><ul>
<li>NIO是JDK1.4提供的操作，他的流还是流，没有改变，服务器实现的还是一个连接一个线程，当是：<code>客户端发送的连接请求都会注册到多路复用器上</code>，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dc3e76709~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看不懂介绍可以认真看看代码实例，其实不难</span><br></pre></td></tr></table></figure>
<h6 id="什么是通道（Channel）"><a href="#什么是通道（Channel）" class="headerlink" title="什么是通道（Channel）"></a>什么是通道（Channel）</h6><ul>
<li>Channel是一个对象，可以通过它读取和写入数据。 通常我们都是将数据写入包含一个或者多个字节的缓冲区，然后再将缓存区的数据写入到通道中，将数据从通道读入缓冲区，再从缓冲区获取数据。</li>
<li>Channel 类似于原I/O中的流（Stream），但有所区别：<ul>
<li>流是单向的，通道是双向的，可读可写。</li>
<li>流读写是阻塞的，通道可以异步读写。</li>
</ul>
</li>
</ul>
<h6 id="什么是选择器（Selector）"><a href="#什么是选择器（Selector）" class="headerlink" title="什么是选择器（Selector）"></a>什么是选择器（Selector）</h6><ul>
<li>Selector可以称他为通道的集合，每次客户端来了之后我们会把Channel注册到Selector中并且我们给他一个状态，在用死循环来环判断(<code>判断是否做完某个操作，完成某个操作后改变不一样的状态</code>)状态是否发生变化，知道IO操作完成后在退出死循环</li>
</ul>
<h6 id="什么是Buffer（缓冲区）"><a href="#什么是Buffer（缓冲区）" class="headerlink" title="什么是Buffer（缓冲区）"></a>什么是Buffer（缓冲区）</h6><ul>
<li>Buffer 是一个缓冲数据的对象， 它包含一些要写入或者刚读出的数据。</li>
<li>在普通的面向流的 I/O 中，一般将数据直接写入或直接读到 Stream 对象中。当是有了Buffer（缓冲区）后，数据第一步到达的是Buffer（缓冲区）中</li>
<li>缓冲区实质上是一个数组(<code>底层完全是数组实现的，感兴趣可以去看一下</code>)。通常它是一个字节数组，内部维护几个状态变量，可以实现在同一块缓冲区上反复读写（不用清空数据再写）。</li>
</ul>
<h6 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h6><ul>
<li><p>目录结构</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dd02ee59c~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
<li><p>运行示例，先运行服务端，在运行所有客户端控制台输入消息就好了。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我这客户端和服务端代码有些修该变，后面有代码</span><br></pre></td></tr></table></figure>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2de8321be5~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
<li><p><code>服务端示例，先运行，想要搞定NIO请认真看代码示例，真的很清楚</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import com.lijie.iob.RequestHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //111111111</span><br><span class="line">        //Service端的Channel，监听端口的</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        //设置为非阻塞</span><br><span class="line">        serverChannel.configureBlocking(false);</span><br><span class="line">        //nio的api规定这样赋值端口</span><br><span class="line">        serverChannel.bind(new InetSocketAddress(8000));</span><br><span class="line">        //显示Channel是否已经启动成功，包括绑定在哪个地址上</span><br><span class="line">        System.out.println(&quot;服务端启动成功，监听端口为8000，等待客户端连接...&quot;+ serverChannel.getLocalAddress());</span><br><span class="line"></span><br><span class="line">        //22222222</span><br><span class="line">        //声明selector选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        //这句话的含义，是把selector注册到Channel上面，</span><br><span class="line">        //每个客户端来了之后，就把客户端注册到Selector选择器上,默认状态是Accepted</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        //33333333</span><br><span class="line">        //创建buffer缓冲区，声明大小是1024，底层使用数组来实现的</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        RequestHandler requestHandler = new RequestHandler();</span><br><span class="line"></span><br><span class="line">        //444444444</span><br><span class="line">        //轮询，服务端不断轮询，等待客户端的连接</span><br><span class="line">        //如果有客户端轮询上来就取出对应的Channel，没有就一直轮询</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int select = selector.select();</span><br><span class="line">            if (select == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //有可能有很多，使用Set保存Channel</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                //使用SelectionKey来获取连接了客户端和服务端的Channel</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                //判断SelectionKey中的Channel状态如何，如果是OP_ACCEPT就进入</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    //从判断SelectionKey中取出Channel</span><br><span class="line">                    ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    //拿到对应客户端的Channel</span><br><span class="line">                    SocketChannel clientChannel = channel.accept();</span><br><span class="line">                    //把客户端的Channel打印出来</span><br><span class="line">                    System.out.println(&quot;客户端通道信息打印：&quot; + clientChannel.getRemoteAddress());</span><br><span class="line">                    //设置客户端的Channel设置为非阻塞</span><br><span class="line">                    clientChannel.configureBlocking(false);</span><br><span class="line">                    //操作完了改变SelectionKey中的Channel的状态OP_READ</span><br><span class="line">                    clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">                //到此轮训到的时候，发现状态是read，开始进行数据交互</span><br><span class="line">                if (key.isReadable()) &#123;</span><br><span class="line">                    //以buffer作为数据桥梁</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    //数据要想读要先写，必须先读取到buffer里面进行操作</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    //进行读取</span><br><span class="line">                    String request = new String(buffer.array()).trim();</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    //进行打印buffer中的数据</span><br><span class="line">                    System.out.println(String.format(&quot;客户端发来的消息： %s : %s&quot;, channel.getRemoteAddress(), request));</span><br><span class="line">                    //要返回数据的话也要先返回buffer里面进行返回</span><br><span class="line">                    String response = requestHandler.handle(request);</span><br><span class="line">                    //然后返回出去</span><br><span class="line">                    channel.write(ByteBuffer.wrap(response.getBytes()));</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>客户端示例：（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我这用的不是之前的了，有修改</span><br></pre></td></tr></table></figure>
<p>）运行起来客户端控制台输入消息就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要模拟测试，请复制粘贴改一下，修改客户端的类名就行了，四个客户端代码一样的</span><br></pre></td></tr></table></figure>
<p>,</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2dee3a5661~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket：客户端</span><br><span class="line">public class Client01 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建套接字对象socket并封装ip与port</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8000);</span><br><span class="line">        //根据创建的socket对象获得一个输出流</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        //控制台输入以IO的形式发送到服务器</span><br><span class="line">        System.out.println(&quot;TCP连接成功 \n请输入：&quot;);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            byte[] car = new Scanner(System.in).nextLine().getBytes();</span><br><span class="line">            outputStream.write(car);</span><br><span class="line">            System.out.println(&quot;TCP协议的Socket发送成功&quot;);</span><br><span class="line">            //刷新缓冲区</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h5 id="5-使用Netty实现网络通信"><a href="#5-使用Netty实现网络通信" class="headerlink" title="5 使用Netty实现网络通信"></a>5 使用Netty实现网络通信</h5><ul>
<li><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
</li>
<li><p>Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的Socket服务开发。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0284e9ca~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
<p>Netty是由NIO演进而来，使用过NIO编程的用户就知道NIO编程非常繁重，Netty是能够能跟好的使用NIO</p>
</li>
</ul>
<ul>
<li><p>Netty的原里就是NIO，他是基于NIO的一个完美的封装，并且优化了NIO，使用他非常方便，简单快捷</p>
</li>
<li><p>我直接上代码：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e0e2ef4ca~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li>1、先添加依赖：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.1.16.Final&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>2、NettyServer 模板，看起来代码那么多，<code>其实只需要添加一行消息就好了</code></li>
<li><code>请认真看中间的代码</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.lijie.iob;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.*;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class="line">import io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class="line">import io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"></span><br><span class="line">public class NettyServer &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(new StringDecoder());</span><br><span class="line">                            pipeline.addLast(&quot;encoder&quot;, new ObjectEncoder());</span><br><span class="line">                            pipeline.addLast(&quot; decoder&quot;, new io.netty.handler.codec.serialization.ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null)));</span><br><span class="line"></span><br><span class="line">                            //重点，其他的都是复用的</span><br><span class="line">                            //这是真正的I0的业务代码，把他封装成一个个的个Hand1e类就行了</span><br><span class="line">                            //把他当成 SpringMVC的Controller</span><br><span class="line">                            pipeline.addLast(new NettyServerHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true);</span><br><span class="line">            ChannelFuture f = b.bind(8000).sync();</span><br><span class="line">            System.out.println(&quot;服务端启动成功，端口号为:&quot; + 8000);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>3、需要做的IO操作，重点是继承ChannelInboundHandlerAdapter类就好了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.lijie.iob;</span><br><span class="line"></span><br><span class="line">import io.netty.channel.Channel;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line">public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    RequestHandler requestHandler = new RequestHandler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(String.format(&quot;客户端信息： %s&quot;, channel.remoteAddress()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        String request = (String) msg;</span><br><span class="line">        System.out.println(String.format(&quot;客户端发送的消息 %s : %s&quot;, channel.remoteAddress(), request));</span><br><span class="line">        String response = requestHandler.handle(request);</span><br><span class="line">        ctx.write(response);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>4 客户的代码还是之前NIO的代码，我在复制下来一下吧</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.test.io;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">//TCP协议Socket：客户端</span><br><span class="line">public class Client01 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建套接字对象socket并封装ip与port</span><br><span class="line">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8000);</span><br><span class="line">        //根据创建的socket对象获得一个输出流</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        //控制台输入以IO的形式发送到服务器</span><br><span class="line">        System.out.println(&quot;TCP连接成功 \n请输入：&quot;);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            byte[] car = new Scanner(System.in).nextLine().getBytes();</span><br><span class="line">            outputStream.write(car);</span><br><span class="line">            System.out.println(&quot;TCP协议的Socket发送成功&quot;);</span><br><span class="line">            //刷新缓冲区</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行测试，还是之前那样，启动服务端，在启动所有客户端控制台输入就好了：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17172a2e4e740749~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904125700784136" target="_blank" rel="noopener">https://juejin.cn/post/6844904125700784136</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-08-14T10:46:13.497Z" itemprop="dateUpdated">2021-08-14 18:46:13</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/" target="_blank" rel="external">https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/</a>
        
    </div>
    
    <footer>
        <a href="https://lywlefan.github.io">
            <img src="/img/avatar.png" alt="share猿">
            share猿
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&title=《java的IO流相关问题》 — share猿&pic=https://lywlefan.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&title=《java的IO流相关问题》 — share猿&source=分享有价值的内容,你我共同成长!" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java的IO流相关问题》 — share猿&url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&via=https://lywlefan.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/03/软件研发/后端/大数据/存储/hive/Hive的CLi骚操作/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Hive的CLi骚操作</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/30/软件研发/后端/大数据/存储/hive/Hive中导入csv数据/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Hive中导入csv数据</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "hQGVIAaJERVwyrWxj1uqgCqS-gzGzoHsz",
            appKey: "l7FO5csTavNwXCGryJyOkkc1",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢赞赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>share猿 &copy; 2015 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&title=《java的IO流相关问题》 — share猿&pic=https://lywlefan.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&title=《java的IO流相关问题》 — share猿&source=分享有价值的内容,你我共同成长!" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java的IO流相关问题》 — share猿&url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/&via=https://lywlefan.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lywlefan.github.io/2020/04/01/软件研发/后端/基础巩固/java/流/java流相关问题/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJElEQVR42u3aQW7jMBAEwPz/09lrgKyd7hkZsOjSyXAkmkUdJpzm11d8ff+4nn//+/Oje/Jn21lddmFjY2PfhP399EruefTUb0zCez7ao/nnFmxsbOxT2clwbRVIADPYbJ7Y2NjY2LPtR/7X9h5sbGxs7A07bznlzabNEmNjY2NjJ4Unjwqel67NNmNWPrGxsbHPZuep6Pt/fkm+jY2Njf3G7Kua+/mz7Wj5lqmYCTY2NvZB7DZqbWOAdqOS/257+BIbGxv7VHbSap+1aWbHdPL51O929jPY2NjYb8/OG/ebxlPS3M+Xcv/CsLGxsU9it4dmksM6bXHKG/35a/hjTGxsbOwPYM82CXmZaQtYCx5uQrCxsbFvzm5j1KQEvqK85THDQxc2Njb2B7CvasTnk8ubR20U/Z9nsbGxsY9j72HtJNrIYbNMDwsYNjY29kHstqmUl5ZZqJAU1E1RxMbGxj6JnffPk+ZOWyPy5dgEwPmrxcbGxr4jezPpvFDlJXA2Qn3oBxsbG/tQ9qxcJSO0LaRNcRqmItjY2NgHsWet/OTIzixgeP59+3qwsbGxz2O3DZ32gOYmGGgPhj6fT50kY2NjY9+E3R5znLXpZ+VwH1E8XAJsbGzso9n7wzRtwpyHBPkS/FGtsLGxsY9mt4FuHhLvNzk58o/vsbGxsQ9i5xuJ2QK1G5i8UOUbkqiXho2NjX1zdrsZ2JSrNr5tQ4UiZsDGxsY+gp23b5JpzWLjPKLYh8f1CSNsbGzsW7Hbf+s3LaF8i3JVtIyNjY19KrvttFzV9Jnh22UqfgsbGxv75ux90ye/P9/SbGKJaLGwsbGxj2O3QyQNqVnZS64LDgZhY2Njfwx7tjHYj5A3qtrFwsbGxj6J/V1eeavoWnwyft05w8bGxj6C/Yp//WdBb97MaudQxL3Y2NjYt2W3cWxbcvLSONuKDOeMjY2NfRx7E+7OooJXN5KwsbGxsWfbjLz9lLeK2qWvz5liY2NjfyS7jXhnZSb5Jh+5zrexsbGxb8XehLubgzjXbmOK8AAbGxv7IPamzLQFZhMz5GFAHhJjY2Nj35z9DzFAFhH4OciqAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '共同学习!共同进步!';
            clearTimeout(titleTime);
        } else {
            document.title = 'Share猿社区官方';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
